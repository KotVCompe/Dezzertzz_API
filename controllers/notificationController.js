const { prisma } = require('../config/database');
const { sendOrderConfirmation, sendOrderStatusUpdate } = require('../utils/email');
const { sendAdminNotification } = require('../utils/telegram');

const notificationController = {
  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  sendTestNotification: async (req, res) => {
    try {
      const { type, message } = req.body;

      if (!type || !message) {
        return res.status(400).json({
          success: false,
          message: 'Type and message are required',
        });
      }

      switch (type) {
        case 'email':
          // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ email
          await sendOrderConfirmation(req.user.email, {
            order_number: 'TEST-ORDER-001',
            total_amount: 999.99,
            items: [
              {
                product: { name: '–¢–µ—Å—Ç–æ–≤—ã–π —Ç–æ–≤–∞—Ä' },
                quantity: 1,
                unit_price: 999.99
              }
            ],
            delivery_address_street: '–¢–µ—Å—Ç–æ–≤–∞—è —É–ª–∏—Ü–∞',
            delivery_address_house: '1',
            user: { first_name: req.user.first_name }
          });
          break;

        case 'telegram':
          // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
          await sendAdminNotification(`üîî –¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: ${message}`);
          break;

        default:
          return res.status(400).json({
            success: false,
            message: 'Invalid notification type',
          });
      }

      res.json({
        success: true,
        message: `Test ${type} notification sent successfully`,
      });
    } catch (error) {
      console.error('Send test notification error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to send test notification',
      });
    }
  },

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  getNotificationSettings: async (req, res) => {
    try {
      const settings = await prisma.userProfile.findUnique({
        where: { user_id: req.user.id },
        select: {
          preferred_notifications: true,
          user: {
            select: {
              email: true,
              phone_number: true,
            },
          },
        },
      });

      // –ü–æ–ª—É—á–∞–µ–º Telegram –ø–æ–¥–ø–∏—Å–∫—É
      const telegramSubscriptions = await prisma.telegramSubscriber.findMany({
        where: {
          first_name: req.user.first_name,
          is_active: true,
        },
      });

      res.json({
        success: true,
        data: {
          email: settings?.user.email || '',
          phone: settings?.user.phone_number || '',
          emailNotifications: settings?.preferred_notifications ?? true,
          telegramSubscriptions: telegramSubscriptions.map(sub => ({
            chatId: sub.chat_id,
            username: sub.username,
            subscribedAt: sub.subscribed_at,
          })),
        },
      });
    } catch (error) {
      console.error('Get notification settings error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get notification settings',
      });
    }
  },

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
  updateNotificationSettings: async (req, res) => {
    try {
      const { emailNotifications, phone } = req.body;

      // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ
      await prisma.userProfile.upsert({
        where: { user_id: req.user.id },
        update: {
          preferred_notifications: emailNotifications,
        },
        create: {
          user_id: req.user.id,
          preferred_notifications: emailNotifications,
        },
      });

      // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –µ—Å–ª–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω
      if (phone) {
        await prisma.user.update({
          where: { id: req.user.id },
          data: {
            phone_number: phone,
            updated_at: new Date(),
          },
        });
      }

      res.json({
        success: true,
        message: 'Notification settings updated successfully',
      });
    } catch (error) {
      console.error('Update notification settings error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update notification settings',
      });
    }
  },

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
  subscribeToTelegram: async (req, res) => {
  try {
    const { chatId, firstName, username } = req.body;

    if (!chatId) {
      return res.status(400).json({
        success: false,
        message: 'Chat ID is required',
      });
    }

    const subscriber = await prisma.telegramSubscriber.upsert({
      where: { chat_id: BigInt(chatId) }, 
      update: {
        first_name: firstName || req.user.first_name,
        username: username,
        is_active: true,
      },
      create: {
        chat_id: BigInt(chatId), 
        first_name: firstName || req.user.first_name,
        username: username,
        is_active: true,
      },
    });

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    const { sendAdminNotification } = require('../utils/telegram');
    await sendAdminNotification(
      `üéâ –ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫: ${subscriber.first_name} (${subscriber.username || '–±–µ–∑ username'})`
    );

    res.json({
      success: true,
      message: 'Subscribed to Telegram notifications successfully',
      data: { 
        subscriber: {
          ...subscriber,
          chat_id: subscriber.chat_id.toString() // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
        }
      },
    });
  } catch (error) {
    console.error('Subscribe to Telegram error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to subscribe to Telegram notifications',
    });
  }
},

  // –û—Ç–ø–∏—Å–∫–∞ –æ—Ç Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
  unsubscribeFromTelegram: async (req, res) => {
  try {
    const { chatId } = req.body;

    if (!chatId) {
      return res.status(400).json({
        success: false,
        message: 'Chat ID is required',
      });
    }

    await prisma.telegramSubscriber.updateMany({
      where: { chat_id: BigInt(chatId) }, 
      data: { is_active: false },
    });

    res.json({
      success: true,
      message: 'Unsubscribed from Telegram notifications successfully',
    });
  } catch (error) {
    console.error('Unsubscribe from Telegram error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to unsubscribe from Telegram notifications',
    });
  }
},

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
  getNotificationHistory: async (req, res) => {
    try {
      const { page = 1, limit = 20, type } = req.query;
      const skip = (parseInt(page) - 1) * parseInt(limit);

      // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã —Ç–∞–±–ª–∏—Ü–∞ —Å –∏—Å—Ç–æ—Ä–∏–µ–π —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
      // –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É

      res.json({
        success: true,
        data: {
          notifications: [],
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total: 0,
            pages: 0,
          },
        },
        message: 'Notification history feature is under development',
      });
    } catch (error) {
      console.error('Get notification history error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get notification history',
      });
    }
  },

  // –û—Ç–ø—Ä–∞–≤–∫–∞ –º–∞—Å—Å–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
  sendBulkNotification: async (req, res) => {
    try {
      const { type, message, target } = req.body;

      if (!type || !message) {
        return res.status(400).json({
          success: false,
          message: 'Type and message are required',
        });
      }

      let sentCount = 0;

      switch (type) {
        case 'telegram':
          // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º Telegram
          const subscribers = await prisma.telegramSubscriber.findMany({
            where: { is_active: true },
          });

          for (const subscriber of subscribers) {
            try {
              await sendAdminNotification(`üì¢ ${message}`);
              sentCount++;
            } catch (error) {
              console.error(`Failed to send to ${subscriber.chat_id}:`, error);
            }
          }
          break;

        case 'email':
          // –û—Ç–ø—Ä–∞–≤–∫–∞ email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
          const users = await prisma.user.findMany({
            where: {
              email_verified: true,
              profile: {
                preferred_notifications: true,
              },
            },
            select: { email: true, first_name: true },
          });

          // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Å—Å–æ–≤–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ email
          // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ —Å—á–∏—Ç–∞–µ–º
          sentCount = users.length;
          break;

        default:
          return res.status(400).json({
            success: false,
            message: 'Invalid notification type for bulk send',
          });
      }

      res.json({
        success: true,
        message: `Bulk notification sent to ${sentCount} recipients`,
        data: { sentCount },
      });
    } catch (error) {
      console.error('Send bulk notification error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to send bulk notification',
      });
    }
  },

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ Telegram –ø–æ–¥–ø–∏—Å–∫–∏
  checkTelegramSubscription: async (req, res) => {
  try {
    const { chatId } = req.query;

    if (!chatId) {
      return res.status(400).json({
        success: false,
        message: 'Chat ID is required',
      });
    }

    const subscription = await prisma.telegramSubscriber.findUnique({
      where: { chat_id: BigInt(chatId) },
    });

    res.json({
      success: true,
      data: {
        isSubscribed: subscription?.is_active || false,
        subscription: subscription ? {
          chatId: subscription.chat_id.toString(), 
          firstName: subscription.first_name,
          username: subscription.username,
          subscribedAt: subscription.subscribed_at,
          isActive: subscription.is_active,
        } : null,
      },
    });
  } catch (error) {
    console.error('Check Telegram subscription error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check subscription status',
    });
  }
},
};

module.exports = notificationController;